<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AigisPay - The Open Payment Trust Layer for P2P Trade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Sora:wght@500;600&display=swap');
        :root {
            --accent-green: #00d7b0;
            --accent-green-soft: #5fffdc;
            --accent-lime: #cfe680;
            --accent-deep: #00131a;
            /* theme bases */
            --bg-starblue: #020612; /* deep starry 'midnight' (near-black, blue tint) */
            --bg-stargray: #0b0b10; /* alternative starry gray */
            --text-primary: #e6fff7;
            --muted: rgba(200,255,220,0.18);
        }
        body {
            margin: 0;
            /* unify fonts to the 'Our mission' stack (monospace-forward) */
            font-family: 'JetBrains Mono', 'Fira Code', 'Space Mono', 'Space Grotesk', 'Sora', system-ui, -apple-system, monospace;
            /* forced pure black background */
            background: #000 !important;
            color: var(--text-primary);
            min-height: 100vh;
            text-align: center;
            padding: 0 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
        }

        body::before {
            /* disable decorative star field to ensure pure black background */
            content: '';
            position: fixed;
            inset: 0;
            opacity: 0 !important;
            z-index: -3;
            pointer-events: none;
        }

        body::after {
            /* disable decorative aurora layer */
            content: '';
            position: fixed;
            inset: -10%;
            opacity: 0 !important;
            z-index: -2;
            pointer-events: none;
        }

        header {
            position: absolute;
            top: 20px;
            left: 20px;
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-primary);
            /* use a clean display face for the logo */
            font-family: 'Space Grotesk', 'Avenir', 'Avenir Next', system-ui, -apple-system, sans-serif;
            z-index: 10;
            text-align: left;
            letter-spacing: 0.4px;
            text-shadow: 0 0 16px rgba(0, 200, 133, 0.25);
        }

        main h2 {
            /* use same font as 'Our mission' */
            font-family: 'JetBrains Mono', 'Fira Code', 'Space Mono', 'Space Grotesk', 'Sora', system-ui, -apple-system, monospace;
            font-weight: 700;
            /* keep it large but allow scaling so it fits one line */
            font-size: clamp(1.6rem, 3.2vw, 2.8rem);
            color: var(--text-primary);
            text-align: center;
            z-index: 10;
            position: relative;
            text-shadow: 0 8px 22px rgba(0, 0, 0, 0.7), 0 0 18px rgba(0, 200, 133, 0.18);
            letter-spacing: -0.2px;
            line-height: 1;
            margin: 0 auto 6px;
            display: block;
            /* ensure heading stays on one line */
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
            max-width: 100%;
        }

        main.hero {
            padding: 8px 22px 40px;
            width: 100%;
            max-width: 980px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 14px;
            position: relative;
            z-index: 5;
            margin: 0 auto;
            flex: 1;
        }

        main.hero::before {
            content: '';
            position: absolute;
            width: 140%;
            height: 160%;
            max-width: 1200px;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 35%, rgba(1, 75, 40, 0.75), rgba(1, 15, 10, 0));
            filter: blur(30px);
            opacity: 0.75;
            z-index: -1;
        }

        footer {
            position: absolute;
            bottom: 10px;
            font-size: 0.875rem;
            color: rgba(200, 255, 205, 0.6);
            font-weight: 600;
            z-index: 10;
            /* match page font stack */
            font-family: 'JetBrains Mono', 'Fira Code', 'Space Mono', 'Space Grotesk', 'Sora', system-ui, -apple-system, monospace;
        }

        .main-description {
            color: #dff9ef;
            /* unify with mission font */
            font-family: 'JetBrains Mono', 'Fira Code', 'Space Mono', 'Space Grotesk', 'Sora', system-ui, -apple-system, monospace;
            font-weight: 400;
            font-size: 1.02rem;
            margin: 0 auto 6px;
            max-width: 820px;
            line-height: 1.95; /* increased for looser reading */
            letter-spacing: 0.18px;
            text-align: center;
            padding: 8px 12px;
        }

        .main-description span {
            display: block;
            margin-bottom: 10px; /* add extra breathing room between lines */
        }

        .secondary-tagline {
            color: rgba(230,255,245,0.95);
            font-family: 'JetBrains Mono', 'Space Grotesk', monospace;
            font-weight: 600;
            font-size: 0.95rem;
            margin: 12px auto 0;
            max-width: 720px;
            letter-spacing: 0.3px;
            text-shadow: 0 0 8px rgba(0,0,0,0.35);
            border-top: 1px solid rgba(200,255,220,0.04);
            padding-top: 12px;
            line-height: 1.45;
        }
        
        @media (max-width: 768px) {
            main h2 {
                font-size: 2rem;
                white-space: normal;
                display: block;
                margin: 0 auto;
                width: 100%;
            }

            main.hero {
                width: 100%;
                max-width: 100%;
            }

        }

        #networkCanvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: -1;
            mix-blend-mode: screen;
            opacity: 0.92;
        }

        #binaryLayer {
            /* limit binary stream visuals to the right third of the viewport */
            position: fixed;
            top: 0;
            right: 0;
            width: 34vw; /* roughly one third */
            max-width: 420px;
            min-width: 260px;
            height: 100vh;
            overflow: hidden;
            pointer-events: none;
            z-index: -2;
            mix-blend-mode: screen;
            opacity: 0.9;
        }

        .stream-column {
            position: absolute;
            top: 0;
            /* width is set dynamically based on available layer width to avoid overlap */
            width: auto;
            opacity: 0.22;
            filter: drop-shadow(0 0 18px rgba(0, 200, 133, 0.45));
            mix-blend-mode: screen;
            box-sizing: border-box;
            overflow: hidden; /* ensure content never escapes column bounds */
        }

        .stream-content {
            display: flex;
            flex-direction: column;
            animation: scrollUp linear infinite;
        }

        .stream-line {
            font-family: 'JetBrains Mono', 'Space Mono', monospace;
            font-size: 13px;
            line-height: 2.4;
            color: rgba(210, 255, 170, 0.6);
            text-shadow: 0 0 12px rgba(0, 200, 133, 0.35);
            /* avoid horizontal overflow: keep single-line and clip */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: clip;
        }

        #flashLayer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }

        .flash-text {
            position: absolute;
            font-family: 'JetBrains Mono', 'Space Mono', monospace;
            font-size: 11px;
            color: rgba(182, 255, 120, 0.8);
            text-shadow: 0 0 14px rgba(0, 200, 133, 0.4);
            animation: flashPulse 2.8s ease-in-out forwards;
        }

        @keyframes auroraBreath {
            0% {
                transform: translate3d(0, 0, 0) scale(1);
                opacity: 0.75;
            }
            100% {
                transform: translate3d(0, -3%, 0) scale(1.06);
                opacity: 1;
            }
        }

        @keyframes scrollUp {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-50%);
            }
        }

        @keyframes flashPulse {
            0% {
                opacity: 0;
                transform: scale(0.92);
            }
            30% {
                opacity: 1;
                transform: scale(1);
            }
            70% {
                opacity: 0.9;
                transform: scale(1.04);
            }
            100% {
                opacity: 0;
                transform: scale(0.95);
            }
        }
        /* Additional styles for cool flowing rays */
    </style>
</head>
<body style="background: #000 !important; background-image: none !important; background-color: #000 !important; font-family: 'Space Grotesk', 'Sora', 'Inter', system-ui, -apple-system, sans-serif !important; color: var(--text-primary) !important;">
    <header style="font-family: 'Sora', 'Inter', 'Avenir Next', system-ui, -apple-system, sans-serif; font-weight: 700; letter-spacing: 1px; color: var(--text-primary);">
        AigisPay
    </header>
    <main class="hero">
    <h2>The Open Trust Layer for P2P Commerce</h2>
        <div class="main-description">
            <span>Delivering smart-contract and agent-based conditional settlement,</span>
            <span>Portable, user-owned, cumulative reputation identities,</span>
            <span>AI-based dispute resolution, fiat–stablecoin interop and more—</span>
            <span>Powering the new wave of the P2P economy in the human–AI symbiotic era.</span>
        </div>
    <!--
    <p class="secondary-tagline"><strong>Our mission：</strong> Build AI-first decentralized commerce for global individuals.<br><strong>Our value：</strong> Trust</p>
    -->
    </main>

    <canvas id="networkCanvas"></canvas>
    <div id="binaryLayer"></div>
    <div id="flashLayer"></div>

    <footer style="font-family: 'JetBrains Mono', 'Fira Code', 'Space Mono', 'Space Grotesk', 'Sora', system-ui, -apple-system, monospace; color: var(--text-primary);">&copy; 2025 Aigis Labs. All rights reserved.</footer>
    <script>
        const binaryLayer = document.getElementById('binaryLayer');
        const flashLayer = document.getElementById('flashLayer');
        const networkCanvas = document.getElementById('networkCanvas');
        const networkCtx = networkCanvas?.getContext('2d');
        const basePatterns = [
            '[ SYSTEM_CORE_ACTIVE ]',
            '[ QUANTUM_SYNC_ENABLED ]',
            '[ NEURAL_BRIDGE_CONNECTED ]',
            '[ MEMORY_BUFFER_STABLE ]',
            '> initializing_neural_pathways',
            '> optimizing_quantum_states',
            '[ SYNAPTIC_LINK_VERIFIED ]',
            '[ CONSCIOUSNESS_MATRIX_STABLE ]',
            '> calibrating_ai_cores',
            '[ QUANTUM_ENTANGLEMENT_READY ]'
        ];
        const flashTerms = [
            '[ QUANTUM_SUPREMACY_ACHIEVED ]',
            '[ NEURAL_BREAKTHROUGH_DETECTED ]',
            '[ CONSCIOUSNESS_EMERGENCE_WARNING ]',
            '[ LEDGER_BLOCK_SEALED ]',
            '[ TRUST_GRAPH_REINFORCED ]',
            '[ CRYPTO_FIAT_BRIDGE_READY ]'
        ];
        const dynamicGenerators = [
            () => `[ NEURAL_SYNC: ${(Math.random() * 0.2 + 0.8).toFixed(3)} ]`,
            () => `[ SYNAPSE_ACTIVITY: ${Math.floor(Math.random() * 1000 + 9000)} ]`,
            () => `[ NEURAL_PLASTICITY: ${(Math.random() * 0.3 + 0.7).toFixed(2)} ]`,
            () => `[ QUANTUM_ENTANGLEMENT: ${(Math.random() * 20 + 80).toFixed(1)}% ]`,
            () => `[ QUBIT_COHERENCE: ${(Math.random() * 0.1 + 0.9).toFixed(3)} ]`,
            () => `[ QUANTUM_STATE_VECTOR: ${Math.floor(Math.random() * 1000)}q ]`,
            () => `[ DEEP_LEARNING_DEPTH: ${Math.floor(Math.random() * 100 + 900)} ]`,
            () => `[ ATTENTION_ENTROPY: ${(Math.random() * 0.5 + 0.5).toFixed(3)} ]`,
            () => `[ MODEL_TEMPERATURE: ${(Math.random() * 0.7 + 0.3).toFixed(2)} ]`
        ];
        let flashInterval;
        let networkNodes = [];

        function buildStreams() {
            if (!binaryLayer) return;
            binaryLayer.innerHTML = '';
            // use binaryLayer width so stream columns fill only the right column area
            const layerWidth = (binaryLayer.clientWidth && binaryLayer.clientWidth > 0) ? binaryLayer.clientWidth : window.innerWidth;
            // estimate desired column width and cap columns to avoid overlaps
            const desiredColWidth = 160; // px per column target
            const maxCols = 6; // don't create too many columns
            let columnCount = Math.max(1, Math.floor(layerWidth / desiredColWidth));
            columnCount = Math.min(columnCount, maxCols);
            for (let i = 0; i < columnCount; i++) {
                const column = document.createElement('div');
                column.className = 'stream-column';
                // place and size columns relative to the binaryLayer area to avoid overlap
                column.style.left = `${(i / columnCount) * 100}%`;
                column.style.width = `${100 / columnCount}%`;
                column.style.animationDuration = `${120 + Math.random() * 40}s`;
                column.style.animationDelay = `${Math.random() * 60}s`;

                const content = document.createElement('div');
                content.className = 'stream-content';
                content.style.animationDuration = `${120 + Math.random() * 60}s`;
                const lines = generateLines();
                content.innerHTML = lines + lines;
                column.appendChild(content);
                binaryLayer.appendChild(column);
            }
        }

        function generateLines() {
            const count = 28;
            let html = '';
            for (let i = 0; i < count; i++) {
                const base = basePatterns[Math.floor(Math.random() * basePatterns.length)];
                const dynamic = dynamicGenerators[Math.floor(Math.random() * dynamicGenerators.length)]();
                html += `<span class="stream-line">${Math.random() > 0.5 ? dynamic : base}</span>`;
            }
            return html;
        }

        function spawnFlash() {
            if (!flashLayer || flashLayer.childElementCount >= 8) return;
            const element = document.createElement('div');
            element.className = 'flash-text';
            element.textContent = flashTerms[Math.floor(Math.random() * flashTerms.length)];
            const pos = getFlashPosition();
            element.style.top = `${pos.top}%`;
            element.style.left = `${pos.left}%`;
            flashLayer.appendChild(element);
            element.addEventListener('animationend', () => element.remove());
        }

        function getFlashPosition() {
            const existing = Array.from(flashLayer.children).map(child => ({
                top: parseFloat(child.style.top) || 0,
                left: parseFloat(child.style.left) || 0
            }));
            for (let attempt = 0; attempt < 40; attempt++) {
                const candidate = { top: Math.random() * 80 + 5, left: Math.random() * 80 + 10 };
                const overlaps = existing.some(pos => Math.abs(pos.top - candidate.top) < 8 && Math.abs(pos.left - candidate.left) < 10);
                if (!overlaps) return candidate;
            }
            return { top: Math.random() * 80 + 5, left: Math.random() * 80 + 10 };
        }

        function startFlashLoop() {
            if (flashInterval) clearInterval(flashInterval);
            flashInterval = setInterval(spawnFlash, 500);
        }

        function resizeNetworkCanvas() {
            if (!networkCanvas) return;
            networkCanvas.width = window.innerWidth;
            networkCanvas.height = window.innerHeight;
        }

        function createNode() {
            const speed = 0.15 + Math.random() * 0.35;
            const angle = Math.random() * Math.PI * 2;
            return {
                x: Math.random() * networkCanvas.width,
                y: Math.random() * networkCanvas.height,
                vx: Math.cos(angle) * (speed * (0.6 + Math.random() * 0.6)),
                vy: Math.sin(angle) * (speed * (0.6 + Math.random() * 0.6)),
                radius: 0.8 + Math.random() * 0.9,
                glow: 0.08 + Math.random() * 0.18
            };
        }

        function rebuildNetworkNodes() {
            if (!networkCanvas) return;
            // further reduce node count to make the dot matrix sparser
            const count = window.innerWidth < 768 ? 10 : 18;
            networkNodes = Array.from({ length: count }, createNode);
        }

        function updateNetworkScene() {
            if (!networkCtx || !networkCanvas) return;
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            networkCtx.clearRect(0, 0, width, height);

            networkNodes.forEach(node => {
                node.x += node.vx;
                node.y += node.vy;
                if (node.x <= 0 || node.x >= width) node.vx *= -1;
                if (node.y <= 0 || node.y >= height) node.vy *= -1;
            });

            for (let i = 0; i < networkNodes.length; i++) {
                for (let j = i + 1; j < networkNodes.length; j++) {
                    const a = networkNodes[i];
                    const b = networkNodes[j];
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    // only draw short connections to reduce clutter
                    const connectThreshold = 90; // shorter distance
                    if (dist < connectThreshold) {
                        const strength = 1 - dist / connectThreshold;
                        networkCtx.beginPath();
                        networkCtx.moveTo(a.x, a.y);
                        networkCtx.lineTo(b.x, b.y);
                        networkCtx.strokeStyle = `rgba(140, 255, 215, ${0.08 * strength})`;
                        networkCtx.lineWidth = 0.6;
                        networkCtx.stroke();
                    }
                }
            }

            networkNodes.forEach(node => {
                networkCtx.beginPath();
                networkCtx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                networkCtx.fillStyle = `rgba(140, 255, 215, ${0.18 + node.glow})`;
                networkCtx.shadowBlur = 8;
                networkCtx.shadowColor = 'rgba(120, 255, 215, 0.45)';
                networkCtx.fill();
                networkCtx.shadowBlur = 0;
            });

            requestAnimationFrame(updateNetworkScene);
        }

        function handleResize() {
            buildStreams();
            resizeNetworkCanvas();
            rebuildNetworkNodes();
        }

        window.addEventListener('resize', handleResize);
        window.addEventListener('load', () => {
            handleResize();
            startFlashLoop();
            updateNetworkScene();
        });
    </script>
</body>
</html>
